import fs from 'fs';
import { execSync } from 'child_process';
import readline from 'readline';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

const ARGS = process.argv.slice(2).reduce((acc, arg) => {
    const [key, value] = arg.split('=');
    acc[key.replace('--', '')] = value;
    return acc;
}, {});

function ask(question) {
    return new Promise((resolve) => {
        rl.question(question, (answer) => resolve(answer));
    });
}

function updateNativeConfig(slug) {
    const configPath = path.join(__dirname, 'src', 'native-config.ts');
    const content = `// Auto-generated by build-mobile-app.js
export const nativeConfig = {
  mode: 'store' as 'platform' | 'store',
  tenantSlug: '${slug}' as string | null
};
`;
    fs.writeFileSync(configPath, content);
    console.log(`‚úÖ Updated src/native-config.ts for store: ${slug}`);
}

function updateCapacitorConfig(appName, appId) {
    const configPath = path.join(__dirname, 'capacitor.config.ts');
    let content = fs.readFileSync(configPath, 'utf8');

    // Replace appId
    content = content.replace(/appId: '.*?',/, `appId: '${appId}',`);
    // Replace appName
    content = content.replace(/appName: '.*?',/, `appName: '${appName}',`);

    fs.writeFileSync(configPath, content);
    console.log(`‚úÖ Updated capacitor.config.ts with Name: "${appName}" and ID: "${appId}"`);
}

async function main() {
    console.log('\nüì± Store Bloom - Whitelabel App Builder');
    console.log('========================================');
    console.log('NOTE: This will create an instant APK without opening Android Studio.');

    const slug = ARGS.slug || await ask('Enter Tenant Slug (e.g. nike-store): ');
    const appName = ARGS.name || await ask('Enter App Name (e.g. Nike Mobile): ');
    const appId = ARGS.id || await ask('Enter App ID (e.g. com.nike.store): ');

    if (!slug || !appName || !appId) {
        console.error('‚ùå Error: All fields are required.');
        process.exit(1);
    }

    console.log('\n‚öôÔ∏è  Configuring project...');

    // 1. Update React Config
    updateNativeConfig(slug);

    // 2. Update Capacitor Config
    updateCapacitorConfig(appName, appId);

    // 3. Build Web Assets
    console.log('\nüèóÔ∏è  1/3 Building Web Assets...');
    const npmCmd = process.platform === 'win32' ? 'npm.cmd' : 'npm';
    try {
        execSync(`${npmCmd} run build`, { stdio: 'inherit', shell: true });
    } catch (e) {
        if (!ARGS.skipBuild) {
            console.error('‚ùå Web Build failed.');
            process.exit(1);
        }
    }

    // 4. Sync Native
    console.log('\nüîÑ 2/3 Syncing to Native...');
    try {
        execSync('npx cap sync', { stdio: 'inherit', shell: true });
    } catch (e) {
        console.error('‚ùå Sync failed.');
        process.exit(1);
    }

    // PATCH: Force Java 17 COMPATIBILITY
    // Capacitor sometimes generates files with VERSION_21, which fails on Java 17 systems.
    console.log('\nüîß Patching Gradle files for Java 17 compatibility...');
    const filesToPatch = [
        path.join(__dirname, 'android', 'capacitor-cordova-android-plugins', 'build.gradle'),
        path.join(__dirname, 'android', 'app', 'build.gradle'),
        path.join(__dirname, 'node_modules', '@capacitor', 'android', 'capacitor', 'build.gradle'),
        path.join(__dirname, 'android', 'app', 'capacitor.build.gradle')
    ];

    filesToPatch.forEach(file => {
        if (fs.existsSync(file)) {
            let content = fs.readFileSync(file, 'utf8');
            if (content.includes('JavaVersion.VERSION_21')) {
                content = content.replace(/JavaVersion.VERSION_21/g, 'JavaVersion.VERSION_17');
                fs.writeFileSync(file, content);
                console.log(`   - Fixed ${path.basename(file)}`);
            }
        }
    });


    // 5. Build APK directly
    console.log('\nü§ñ 3/3 Compiling APK (This may take 2-3 mins)...');
    const isWin = process.platform === 'win32';
    const gradleCmd = isWin ? 'gradlew.bat' : './gradlew';
    const androidDir = path.join(__dirname, 'android');

    try {
        // Run gradle assembleDebug
        execSync(`${gradleCmd} assembleDebug`, {
            cwd: androidDir,
            stdio: 'inherit',
            shell: true
        });

        console.log('\nüì¶ Move and Rename APK...');

        // Path to the output APK
        const apkPath = path.join(androidDir, 'app', 'build', 'outputs', 'apk', 'debug', 'app-debug.apk');

        // Destination path
        const safeName = appName.replace(/[^a-z0-9]/gi, '_').toLowerCase();
        const destPath = path.join(__dirname, `${safeName}.apk`);

        if (fs.existsSync(apkPath)) {
            fs.copyFileSync(apkPath, destPath);
            console.log(`\nüéâ SUCCESS! App created:`);
            console.log(`üëâ ${destPath}`);
            console.log(`\n(You can send this APK file directly to your client)`);
        } else {
            console.error('‚ùå Error: APK file was not found after build.');
        }

    } catch (e) {
        console.error('‚ùå Android Build failed. Make sure Java/Android SDK is installed.');
        console.error(e.message);
        process.exit(1);
    }

    rl.close();
}

main();
